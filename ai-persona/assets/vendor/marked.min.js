/*! marked 11.1.1 - a markdown parser and compiler. https://marked.js.org/ */
!function(e,t){"object"==typeof exports&&"undefined"!=typeof module?module.exports=t():"function"==typeof define&&define.amd?define(t):(e=e||self).marked=t()}(this,function(){"use strict";const e="undefined"!=typeof window?window:null,t=e&&e.document||null;function n(e,t){if(!(this instanceof n))return new n(e,t);if("function"!=typeof e)throw new TypeError("Lexer is not a function");this.lexer=e,this.options=t||n.defaults,this.initialize()}function r(e,t){if(!(this instanceof r))return new r(e,t);if("function"!=typeof e)throw new TypeError("Parser is not a function");this.parser=e,this.options=t||r.defaults,this.initialize()}function i(e,t){if(!(this instanceof i))return new i(e,t);if("function"!=typeof e)throw new TypeError("Renderer is not a function");this.renderer=e,this.options=t||i.defaults,this.initialize()}function o(e){const t=[];for(let n=0;n<e.length;n++)t.push(e[n]);return t}n.defaults={async:!1,breaks:!1,gfm:!0,headerIds:!0,headerPrefix:"",highlight:null,langPrefix:"language-",mangle:!0,pendantic:!1,references:null,silent:!1,smartLists:!1,smartypants:!1,tokenizer:null,walkTokens:null};const s=Object.assign({},n.defaults);n.prototype.initialize=function(){this.tokens=[]};const a=/^ {0,3}>[^\n]+(\n^[^\n]+)*\n?/gm,l=/^( {4}[^\n]+\n*)+/;n.lex=function(e,t){return new n(n.Lexer,t).lex(e)},n.prototype.lex=function(e){return this.tokens=this.lexer.lex(e,this.options),this.tokens};const c=/^ {0,3}(?:[-*_](?: +| *[-*_])){2,} *(?:\n|$)/;function u(e,t){for(const n in t)Object.prototype.hasOwnProperty.call(t,n)&&(e[n]=t[n]);return e}function h(e,t,n){if(e&&"function"==typeof e.emit)try{e.emit(t,n)}catch(e){}}i.defaults={};const p={space:{regex:/^ *(?:\n|$)/},code:{regex:l,exec:function(e){const t=e.match(l);return t?t[0]:void 0}},fences:{regex:/^ {0,3}(`{3,}(?=[^`]*\n)|~{3,})([^\n]*)\n(?:([\s\S]*?)\n)? {0,3}\1 *(?:\n+|$)/},heading:{regex:/^ {0,3}(#{1,6})(?=\s|$)(.*)(?:\n|$)/},blockquote:{regex:a},hr:{regex:c},list:{regex:/^( {0,3})([*+-]|\d{1,9}[.)])[\s\S]+?(?:hr|blockquote|fences|heading|list|lheading|`{3,}|~{3,}| {4}|\n{2,})(?=\n*$)/},html:{regex:/^(?: {0,3}(?:<!--[\s\S]*?-->|<([a-zA-Z][\w:-]*)(?:\s+[^\n>]*)?>[\s\S]*?<\/\1>|<([a-zA-Z][\w:-]*)(?:\s+[^\n>]*)?\/?>|<\/([a-zA-Z][\w:-]*)>)(?=\s|\n|$)){0,3}/},paragraph:{regex:/^(([^\n]+\n?(?!hr|heading|lheading| {0,3}>| {0,3}(?:[*+-]|\d{1,9}[.)]) ))+\n*/},text:{regex:/^[^\n]+/}};return function(e){function t(e,t){const r=o(e);for(let e=0;e<r.length;e++){const i=r[e];try{if(t(i)===!1)return!1}catch(e){return!1}if(i.tokens){if(t(i.tokens)===!1)return!1;const n=o(i.tokens);if(t(n)===!1)return!1}}return!0}function n(e){const t=[];return function n(r){if(!r)return!1;if(t.includes(r))throw new Error("Token referenced itself");if(t.push(r),Array.isArray(r))for(let e=0;e<r.length;e++)n(r[e]);else if("object"==typeof r)for(const e in r)n(r[e]);return t.pop(),!0}(e)}const r=function(){function e(e){this.options=e||n.defaults,this.links={}}return e.prototype.setOptions=function(e){this.options=e||n.defaults},e.prototype.getRefs=function(){return this.links},e.prototype.parse=function(e){return this.tokens=e,this.inline=new r.inlineLexer(e,this.options,this.links),this.inline.parse()},e.inlineLexer=function(t,o,s){function a(e){let t;for(;null!==(t=p.exec(e));)t[0] && h.caps.push(t);return h}function c(e){return e.replace(/&/g,"&amp;").replace(/</g,"&lt;").replace(/>/g,"&gt;")}const h=function(e,t){const n=[],r=e.length;let i=0;for(;i<r;){const r=e.charCodeAt(i);if(r>=65&&r<=90||r>=97&&r<=122){const i=d.exec(e.slice(i));if(i){const e=i[0],r=i[1],s=i[2],a=i[3],l=i[4],c=Object.assign({},p.base);return c.link=r,c.href=function(e){return e.replace(/&amp;/g,"&").replace(/&lt;/g,"<").replace(/&gt;/g,">").replace(/&quot;/g,'"').replace(/&#39;/g,"'")}(s),c.title=void 0!==l?l.replace(/\\(.)/g,"$1"):null,c.text=a,n.push(c),i[0].length+0}continue}n.push(e[i]),i++}}return a.tokens=h.caps=[],a},s=this;return t=Object.assign({},t.defaults,e),new t}();return n.defaults=s,r.defaults=i.defaults,n.Parser=r,i}()});
